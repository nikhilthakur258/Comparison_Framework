pyinstaller --onefile --add-data "templates;templates" --add-data "static;static" --add-data "scripts;scripts" app.py

class UnionFind:
    def __init__(self, N):
        self.rank = [0] * N
        self.setSize = [1] * N
        self.p = list(range(N))
        self.numSets = N

    def findSet(self, i):
        return i if self.p[i] == i else self.findSet(self.p[i])

    def isSameSet(self, i, j):
        return self.findSet(i) == self.findSet(j)

    def unionSet(self, i, j):
        if not self.isSameSet(i, j):
            self.numSets -= 1
            x, y = self.findSet(i), self.findSet(j)
            if self.rank[x] > self.rank[y]:
                self.p[y] = x
                self.setSize[x] += self.setSize[y]
            else:
                self.p[x] = y
                self.setSize[y] += self.setSize[x]
                if self.rank[x] == self.rank[y]:
                    self.rank[y] += 1

    def numDisjointSets(self):
        return self.numSets

    def sizeOfSet(self, i):
        return self.setSize[i]


class SegmentTree:
    def __init__(self, A):
        self.A = A
        self.n = len(A)
        self.st = [0] * (4 * self.n)
        self.build(1, 0, self.n - 1)

    def left(self, p):
        return p << 1

    def right(self, p):
        return (p << 1) + 1

    def build(self, p, L, R):
        if L == R:
            self.st[p] = L
        else:
            self.build(self.left(p), L, (L + R) // 2)
            self.build(self.right(p), (L + R) // 2 + 1, R)
            p1, p2 = self.st[self.left(p)], self.st[self.right(p)]
            self.st[p] = p1 if self.A[p1] < self.A[p2] else p2

    def rmq(self, p, L, R, i, j):
        if i > R or j < L:
            return -1
        if L >= i and R <= j:
            return self.st[p]
        p1 = self.rmq(self.left(p), L, (L + R) // 2, i, j)
        p2 = self.rmq(self.right(p), (L + R) // 2 + 1, R, i, j)
        if p1 == -1:
            return p2
        if p2 == -1:
            return p1
        return p1 if self.A[p1] < self.A[p2] else p2

    def update_point(self, p, L, R, idx, new_value):
        i, j = idx, idx
        if i > R or j < L:
            return self.st[p]
        if L == i and R == j:
            self.A[i] = new_value
            return self.st[p] = L
        p1 = self.update_point(self.left(p), L, (L + R) // 2, idx, new_value)
        p2 = self.update_point(self.right(p), (L + R) // 2 + 1, R, idx, new_value)
        return self.st[p] = p1 if self.A[p1] < self.A[p2] else p2


if __name__ == "__main__":
    print("Assume that there are 5 disjoint sets initially")
    UF = UnionFind(5)
    print(UF.numDisjointSets())  # 5
    UF.unionSet(0, 1)
    print(UF.numDisjointSets())  # 4
    UF.unionSet(2, 3)
    print(UF.numDisjointSets())  # 3
    UF.unionSet(4, 3)
    print(UF.numDisjointSets())  # 2
    print("isSameSet(0, 3) =", UF.isSameSet(0, 3))  # will return 0 (false)
    print("isSameSet(4, 3) =", UF.isSameSet(4, 3))  # will return 1 (true)
    for i in range(5):
        print("findSet({}) = {}, sizeOfSet({}) = {}".format(i, UF.findSet(i), i, UF.sizeOfSet(i)))
    UF.unionSet(0, 3)
    print(UF.numDisjointSets())  # 1
    for i in range(5):
        print("findSet({}) = {}, sizeOfSet({}) = {}".format(i, UF.findSet(i), i, UF.sizeOfSet(i)))

    arr = [18, 17, 13, 19, 15, 11, 20]
    A = arr
    st = SegmentTree(A)

    print("              idx    0, 1, 2, 3, 4,  5, 6")
    print("              A is {18,17,13,19,15, 11,20}")
    print("RMQ(1, 3) =", st.rmq(1, 3))  # answer = index 2
    print("RMQ(4, 6) =", st.rmq(4, 6))  # answer = index 5
    print("RMQ(3, 4) =", st.rmq(3, 4))  # answer = index 4
    print("RMQ(0, 0) =", st.rmq(0, 0))  # answer = index 0
    print("RMQ(0, 1) =", st.rmq(0, 1))  # answer = index 1
    print("RMQ(0, 6) =", st.rmq(0, 6))
    print("              idx    0, 1, 2, 3, 4,  5, 6")
    print("Now, modify A into {18,17,13,19,15,100,20}")
    st.update_point(5, 100)
    print("These values do not change")
    print("RMQ(1, 3) =", st.rmq(1, 3))  # 2
    print("RMQ(3, 4) =", st.rmq(3, 4))  # 4
    print("RMQ(0, 0) =", st.rmq(0, 0))  # 0
    print("RMQ(0, 1) =", st.rmq(0, 1))  # 1
    print("These values change")
    print("RMQ(0, 6) =", st.rmq(0, 6))  # 5->2
    print("RMQ(4, 6) =", st.rmq(4, 6))  # 5->4
    print("RMQ(4, 5) =", st.rmq(4, 5))  # 5->4


============================================================================


c++

#include <cstdio> 
#include <vector> 
#include <string> 
using namespace std; 
 
typedef vector<int> vi; 
 
class UnionFind{ 
	private:  
		vi rank,setSize,p; 
		int numSets; 
	public: 
		UnionFind(int N){ rank.assign(N,0);setSize.assign(N,1); 
		p.assign(N,0);numSets=N;for (int i=0;i<N;i++)p[i]=i; } 
		int findSet(int i){return (p[i] == i) ? i : (p[i]=findSet(p[i]));} 
		bool isSameSet(int i, int j) {return findSet(i) == findSet(j);} 
		void unionSet(int i, int j){ 
			if(!isSameSet(i,j)){ --numSets; 
				int x = findSet(i), y = findSet(j); 
				if (rank[x]>rank[y]) {p[y]=x;setSize[x]+=setSize[y];} 
				else{p[x]=y;setSize[y]+=setSize[x]; 
					if (rank[x] == rank[y]) rank[y]++; 
				}}} 
		int numDisjointSets(){return numSets;} 
		int sizeOfSet(int i){return setSize[i];} 
}; 
 
class SegmentTree{ 
	private: 
		vi st,A; 
		int n; int left (int p){return (p << 1);} 
			int right (int p){return (p<<1)+1;} 
	 
	void build (int p, int L, int R){if (L==R) st[p]=L; 
	else{build(left(p), L, (L+R)/2); build (right(p), (L+R)/2 + 1, R); 
	int p1 = st[left(p)], p2 = st[right(p)]; st[p] = (A[p1]<A[p2]) ? p1 : p2;}} 
	 
	int rmq (int p, int L, int R, int i, int j){if(i>R||j<L) 
		return -1; if (L >= i && R <= j) return st[p];  
		int p1 = rmq(left(p), L, (L+R)/2 , i, j);  
		int p2 = rmq(right(p), (L+R)/2+1, R, i , j);  
		if (p1 == -1) return p2; if (p2 == -1) return p1; 
		return (A[p1] < A[p2]) ? p1 : p2;} 
	 
	int update_point (int p, int L, int R, int idx, int new_value){int i=idx,j=idx; 
		if (i>R || j<L) return st[p]; if (L == i && R == j) {A[i]=new_value;return st[p]=L;} 
		int p1 = update_point(left(p),L,(L+R)/2,idx,new_value),p2 = update_point(right(p),(L+R)/2+1,R,idx,new_value); 
		return st[p] = (A[p1] < A[p2]) ? p1 : p2;} 
	 
	public: 
		SegmentTree(const vi&_A){A=_A; 
		n=(int)A.size();st.assign(4*n,0);build(1,0,n-1);} 
		int rmq (int i, int j){return rmq(1,0,n-1,i,j);} 
		int update_point(int idx, int new_value){return update_point(1,0,n-1,idx,new_value);} 
}; 
 
int main (int argc, char *argv[]){ 
printf("Assume that there are 5 disjoint sets initially\n"); 
  UnionFind UF(5); // create 5 disjoint sets 
  printf("%d\n", UF.numDisjointSets()); // 5 
  UF.unionSet(0, 1); 
  printf("%d\n", UF.numDisjointSets()); // 4 
  UF.unionSet(2, 3); 
  printf("%d\n", UF.numDisjointSets()); // 3 
  UF.unionSet(4, 3); 
  printf("%d\n", UF.numDisjointSets()); // 2 
  printf("isSameSet(0, 3) = %d\n", UF.isSameSet(0, 3)); // will return 0 (false) 
  printf("isSameSet(4, 3) = %d\n", UF.isSameSet(4, 3)); // will return 1 (true) 
  for (int i = 0; i < 5; i++) // findSet will return 1 for {0, 1} and 3 for {2, 3, 4} 
    printf("findSet(%d) = %d, sizeOfSet(%d) = %d\n", i, UF.findSet(i), i, UF.sizeOfSet(i)); 
  UF.unionSet(0, 3); 
  printf("%d\n", UF.numDisjointSets()); // 1 
  for (int i = 0; i < 5; i++) // findSet will return 3 for {0, 1, 2, 3, 4} 
    printf("findSet(%d) = %d, sizeOfSet(%d) = %d\n", i, UF.findSet(i), i, UF.sizeOfSet(i)); 
	int arr[] = { 18, 17, 13, 19, 15, 11, 20 };         // the original array 
  vi A(arr, arr + 7);                      // copy the contents to a vector 
  SegmentTree st(A); 
 
  printf("              idx    0, 1, 2, 3, 4,  5, 6\n"); 
  printf("              A is {18,17,13,19,15, 11,20}\n"); 
  printf("RMQ(1, 3) = %d\n", st.rmq(1, 3));             // answer = index 2 
  printf("RMQ(4, 6) = %d\n", st.rmq(4, 6));             // answer = index 5 
  printf("RMQ(3, 4) = %d\n", st.rmq(3, 4));             // answer = index 4 
  printf("RMQ(0, 0) = %d\n", st.rmq(0, 0));             // answer = index 0 
  printf("RMQ(0, 1) = %d\n", st.rmq(0, 1));             // answer = index 1 
  printf("RMQ(0, 6) = %d\n", st.rmq(0, 6));     
  printf("              idx    0, 1, 2, 3, 4,  5, 6\n"); 
  printf("Now, modify A into {18,17,13,19,15,100,20}\n"); 
  st.update_point(5, 100);                    // update A[5] from 11 to 100 
  printf("These values do not change\n"); 
  printf("RMQ(1, 3) = %d\n", st.rmq(1, 3));                            // 2 
  printf("RMQ(3, 4) = %d\n", st.rmq(3, 4));                            // 4 
  printf("RMQ(0, 0) = %d\n", st.rmq(0, 0));                            // 0 
  printf("RMQ(0, 1) = %d\n", st.rmq(0, 1));                            // 1 
  printf("These values change\n"); 
  printf("RMQ(0, 6) = %d\n", st.rmq(0, 6));                         // 5->2 
  printf("RMQ(4, 6) = %d\n", st.rmq(4, 6));                         // 5->4 
  printf("RMQ(4, 5) = %d\n", st.rmq(4, 5));                         // 5->4 
 
  return 0;		 
} 

==============================================================================================

Code Architecture Document

Introduction:
This C++ program is organized into two main classes, UnionFind and SegmentTree, and a main function demonstrating their usage. The code leverages the Standard Template Library (STL) components such as vectors and utilizes concepts like Union-Find and Segment Trees.

1. Union-Find Class (UnionFind):
1.1. Purpose:
This class implements the Union-Find data structure, allowing efficient tracking of disjoint sets and performing union operations.

1.2. Class Members:
rank: Vector storing the rank of each element in the disjoint sets.
setSize: Vector keeping track of the size of each set.
p: Vector representing the parent of each element.
numSets: Number of disjoint sets.
1.3. Public Methods:
UnionFind(int N): Constructor initializing the Union-Find structure with N disjoint sets.
findSet(int i): Finds the representative of the set to which element i belongs.
isSameSet(int i, int j): Checks if elements i and j belong to the same set.
unionSet(int i, int j): Unites the sets to which elements i and j belong.
numDisjointSets(): Returns the current number of disjoint sets.
sizeOfSet(int i): Returns the size of the set to which element i belongs.
2. SegmentTree Class (SegmentTree):
2.1. Purpose:
This class implements a Segment Tree data structure for efficient range minimum queries (RMQ) and updates.

2.2. Class Members:
st: Vector representing the segment tree.
A: Original array.
n: Size of the array.
2.3. Private Methods:
build(p, L, R): Recursively builds the segment tree.
rmq(p, L, R, i, j): Finds the index of the minimum element in the range [i, j].
update_point(p, L, R, idx, new_value): Updates the value of the array at index idx.
2.4. Public Methods:
SegmentTree(const vi&_A): Constructor initializing the Segment Tree with the given array.
rmq(i, j): Returns the index of the minimum element in the range [i, j].
update_point(idx, new_value): Updates the value at index idx in the array.
3. Main Function (main):
3.1. Purpose:
The main function serves as the entry point of the program, demonstrating the usage of both the UnionFind and SegmentTree classes.

3.2. Key Features:
Creates a UnionFind object and performs union operations on disjoint sets.
Prints the number of disjoint sets, checks set relationships, and displays set sizes.
Creates a SegmentTree object, performs RMQ operations, and updates array values.
Outputs results and changes in RMQ values after array modifications.
4. Code Execution Flow:
Union-Find Operations:

Initialize a UnionFind object with 5 disjoint sets.
Perform union operations and display the changes in the number of disjoint sets.
Check if certain elements are in the same set and print set sizes.
Segment Tree Operations:

Create a SegmentTree object with an initial array.
Perform RMQ operations on different ranges and display the results.
Update a value in the array and observe changes in RMQ results.
5. Conclusion:
The code effectively demonstrates the implementation and usage of Union-Find and Segment Tree data structures. The modular and organized structure of the code enhances readability and ease of understanding. The main function provides a clear illustration of the capabilities of the implemented classes
