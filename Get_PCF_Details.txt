import subprocess
import pandas as pd
import logging
import argparse

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def run_cf_command(command):
    logging.info(f"Running command: {' '.join(command)}")
    try:
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True, text=True)
        logging.info(f"Command succeeded: {' '.join(command)}")
        return result.stdout
    except subprocess.CalledProcessError as e:
        logging.error(f"Error running command {command}: {e.stderr}")
        return None

def get_app_info(limit=None):
    logging.info("Fetching list of apps...")
    app_list_command = ["cf", "apps"]
    app_list = run_cf_command(app_list_command)
    if not app_list:
        return None

    # Parse the app list to get app names
    apps = []
    for line in app_list.splitlines()[4:]:  # Skip the header lines
        parts = line.split()
        if parts:
            apps.append(parts[0])
    
    if limit:
        apps = apps[:limit]

    app_details = []

    for app in apps:
        logging.info(f"Fetching details for app: {app}")
        app_info = {}

        # Get app details
        app_command = ["cf", "app", app]
        app_details_output = run_cf_command(app_command)
        if not app_details_output:
            continue

        # Extract relevant information
        app_info['name'] = app
        for line in app_details_output.splitlines():
            if 'instances:' in line:
                app_info['instances'] = line.split(':')[1].strip().split('/')[0].strip()
            elif 'memory:' in line:
                app_info['memory'] = line.split(':')[1].strip()
            elif 'routes:' in line:
                app_info['routes'] = line.split(':')[1].strip()
            elif 'buildpacks:' in line:
                app_info['buildpacks'] = line.split(':')[1].strip()

        # Extract buildpack details
        app_info['buildpacks_info'] = []
        buildpacks_start = False
        for line in app_details_output.splitlines():
            if 'buildpack' in line and 'name' in line and 'version' in line and 'detect output' in line:
                buildpacks_start = True
                continue
            if buildpacks_start and line.strip():
                parts = [part.strip() for part in line.split() if part.strip()]
                if len(parts) >= 3:
                    app_info['buildpacks_info'].append({
                        'name': parts[0],
                        'version': parts[1],
                        'detect_output': ' '.join(parts[2:])
                    })
            elif buildpacks_start and not line.strip():
                break

        # Ensure all keys are present in the app_info dictionary
        app_info.setdefault('instances', 'N/A')
        app_info.setdefault('memory', 'N/A')
        app_info.setdefault('routes', 'N/A')
        app_info.setdefault('buildpacks', 'N/A')

        app_details.append(app_info)

    return app_details

def get_service_info():
    logging.info("Fetching list of services...")
    services_command = ["cf", "services"]
    services_output = run_cf_command(services_command)
    if not services_output:
        return None

    services = []
    for service_line in services_output.splitlines()[4:]:  # Skip the header lines
        service_parts = service_line.split()
        if len(service_parts) >= 5:
            service_name = service_parts[0]
            service_type = service_parts[1]
            service_plan = service_parts[2]
            bound_apps = service_parts[3].split(",") if service_parts[3] else []
            last_operation = ' '.join(service_parts[4:])
            for bound_app in bound_apps:
                services.append({
                    "service_name": service_name,
                    "service_type": service_type,
                    "plan": service_plan,
                    "bound_app": bound_app.strip(),
                    "last_operation": last_operation
                })

    return services

def create_excel_file(app_info, service_info):
    logging.info("Creating Excel file...")
    data = []
    for app in app_info:
        app_name = app['name']
        services = [service for service in service_info if service['bound_app'] == app_name]
        num_services = len(services)
        buildpack_details = ', '.join([f"{bp['name']} (version: {bp['version']}, detect_output: {bp['detect_output']})" for bp in app.get('buildpacks_info', [])])
        for service in services:
            data.append({
                "PCF App Name": app['name'],
                "Number of Instances": app['instances'],
                "Memory": app['memory'],
                "Number of Services Bound": num_services,
                "Routes": app['routes'],
                "Buildpacks": buildpack_details,
                "Service Name": service['service_name'],
                "Service Plan": service['plan'],
                "Service Instance": service['service_type'],
            })
        if not services:  # If no services are bound, add an entry with N/A for service details
            data.append({
                "PCF App Name": app['name'],
                "Number of Instances": app['instances'],
                "Memory": app['memory'],
                "Number of Services Bound": num_services,
                "Routes": app['routes'],
                "Buildpacks": buildpack_details,
                "Service Name": 'N/A',
                "Service Plan": 'N/A',
                "Service Instance": 'N/A',
            })

    df = pd.DataFrame(data)
    df.to_excel('app_info.xlsx', index=False)
    logging.info("Excel file 'app_info.xlsx' created successfully.")

def main():
    parser = argparse.ArgumentParser(description="Fetch PCF application and service details.")
    parser.add_argument('-n', '--num_apps', type=int, help="Number of apps to process")
    args = parser.parse_args()

    logging.info("Starting PCF application info retrieval script...")

    # Set API endpoint with skip SSL validation
    api_command = [
        "cf", "api", 
        "API_ENDPOINT", 
        "--skip-ssl-validation"
    ]
    run_cf_command(api_command)

    # Log in to PCF
    login_command = [
        "cf", "login", 
        "-u", "USERNAME", 
        "-p", "PASSWORD", 
        "-o", "ORG", 
        "-s", "SPACE"
    ]
    run_cf_command(login_command)

    app_info = get_app_info(limit=args.num_apps)
    service_info = get_service_info()

    if app_info and service_info:
        create_excel_file(app_info, service_info)
    else:
        logging.error("Failed to retrieve application or service details.")

    logging.info("Script finished.")

if __name__ == "__main__":
    main()
